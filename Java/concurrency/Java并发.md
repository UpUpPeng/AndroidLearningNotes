<!-- TOC -->

- [1. 基本概念](#1-基本概念)
  - [1.1. 进程与线程](#11-进程与线程)
    - [1.1.1. 二者概念](#111-二者概念)
    - [1.1.2. 二者区别](#112-二者区别)
  - [1.2. 并行与并发](#12-并行与并发)
- [2. 线程](#2-线程)
  - [2.1. 线程运行的原理](#21-线程运行的原理)
    - [2.1.1. 栈与栈帧](#211-栈与栈帧)
    - [2.1.2. 线程上下文切换](#212-线程上下文切换)
  - [2.2. 常见方法](#22-常见方法)
    - [2.2.1. start() 和 run()](#221-start-和-run)

<!-- /TOC -->

# 1. 基本概念

## 1.1. 进程与线程

### 1.1.1. 二者概念

**【进程】**

- 进程是操作系统结构的基础，是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的基本单位。
- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO等。
- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。
- 进程就可以视为程序的一个实例。有的程序可以同时运行多个实例进程（浏览器），有的只能运行一个实例进程（QQ音乐）

**【线程】**

- 线程是操作系统调度的最小单位，也叫作轻量级进程。
- 一个进程内可以分为多个线程。
- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行。
- Java中，线程作为最小调度单位，进程作为资源分配的最小单位。在windows中进程是不活动的，只是作为线程的容器。

### 1.1.2. 二者区别

- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集。

- 迸程拥有共享的资源，如内存空间等，供其内部的线程共享。

- 进程间通信较为复杂：

  - 同一台计算机的进程通信称为 IPC (Inter-process communication)。
  - 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如http。

- 线程通信相对简单，因为它们共享进程内的内存，例如多个线程可以访问同一个共享变量。

- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低。

## 1.2. 并行与并发

**【并行 parallel】**

在同一时刻，有多条指令在多个处理器上同时执行。在宏观上和微观上，都是一起执行的。

![](https://picture-1251081707.cos.ap-shanghai.myqcloud.com/20201201-184230-52617f9d1193e7465fcdbad1a1876225.png)

当系统有一个以上 CPU 时，则线程的操作有可能并行。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行。

**【并发 concurrency】**

在同一时刻，只有一条指令执行，但多个指令被快速的轮换执行。在宏观上是一起执行的效果，在微观上不是一起执行。

![](https://picture-1251081707.cos.ap-shanghai.myqcloud.com/20201201-184321-d3f51415b0b3e53bf15b9fc304400284.png)

当系统只有一个 CPU时，则它不可能同时进行一个以上的线程，只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。

------

# 2. 线程

## 2.1. 线程运行的原理

### 2.1.1. 栈与栈帧

JVM 虚拟机在每个线程启动后，就会为其分配一块 Java 虚拟机栈内存。

- 每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存。
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。

### 2.1.2. 线程上下文切换

因为一些原因导致cpu不再执行当前的线程，转而执行另一个线程的代码。

- 线程的cpu时间片用完。
- 垃圾回收。
- 有更高优先级的线程需要运行。
- 线程自己调用了sleep、yield、wait、join、park、synchronized、lock等方法。

当上下文切换发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中程序计数器就是用来记住下一条jvm指令的执行地址， 是线程私有的。

- 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等。
- 上下文切换频繁发生会影响性能。 

## 2.2. 常见方法

### 2.2.1. start() 和 run()

- `start()`：启动线程，真正实现了多线程运行，这时无需等待 run 方法体代码执行完毕而直接继续执行下面的代码。通过调用 Thread 类的 start() 方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到 cpu 时间片，就开始执行 run() 方法，这里方法 run() 称为线程体，它包含了要执行的这个线程的内容，Run 方法运行结束，此线程随即终止。
- `run()`： 只是类的一个普通方法而已，如果直接调用 Run 方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待 run 方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。总结：调用 start 方法方可启动线程，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在 run() 方法中，start() 方法启动线程将自动调用 run() 方法，这是由 jvm 的内存机制规定的。并且 run() 方法必须是 public 访问权限，返回值类型为 void。
<!-- TOC -->

- [1. 类的加载过程](#1-类的加载过程)
  - [1.1. 加载](#11-加载)
    - [1.1.1. 非数组类](#111-非数组类)
    - [1.1.2. 数组类](#112-数组类)
  - [1.2. 验证](#12-验证)
    - [1.2.1. 文件格式验证](#121-文件格式验证)
    - [1.2.2. 元数据验证](#122-元数据验证)
    - [1.2.3. 字节码验证](#123-字节码验证)
    - [1.2.4. 符号引用验证](#124-符号引用验证)
  - [1.3. 准备](#13-准备)
  - [1.4. 目标变量](#14-目标变量)
    - [1.4.1. 初始值](#141-初始值)
  - [1.5. 解析](#15-解析)
  - [1.6. 初始化](#16-初始化)
    - [1.6.1. 初始化顺序](#161-初始化顺序)
    - [1.6.2. 主动引用（初始化时机）](#162-主动引用初始化时机)
    - [1.6.3. 被动引用](#163-被动引用)
- [2. 类加载器](#2-类加载器)
  - [2.1. 类加载器的分类](#21-类加载器的分类)
    - [2.1.1. 引导类加载器（bootstrap class loader）](#211-引导类加载器bootstrap-class-loader)
    - [2.1.2. 扩展类加载器（extensions class loader）](#212-扩展类加载器extensions-class-loader)
    - [2.1.3. 应用程序类加载器（application class loader）](#213-应用程序类加载器application-class-loader)
    - [2.1.4. 自定义类加载器](#214-自定义类加载器)
  - [2.2. 类加载步骤](#22-类加载步骤)
  - [2.3. 类加载机制](#23-类加载机制)
  - [2.4. 双亲委派](#24-双亲委派)
    - [2.4.1. 执行流程](#241-执行流程)
    - [2.4.2. 双亲委派的优点](#242-双亲委派的优点)
    - [2.4.3. 破坏双亲委派](#243-破坏双亲委派)

<!-- /TOC -->

# 1. 类的加载过程

>  https://www.jianshu.com/p/d432a94be182

Java 类加载分为 5 个过程，分别为：加载，连接 (验证，准备，解析)，初始化，使用，卸载。

![img](https://raw.githubusercontent.com/ren-p/AndroidLearningNotes/main/img/20201128-210000-14084d0d8220cda2ebd55d8bb60c4be6.png)

- 绑定/晚期绑定）。
- 这些阶段按顺序开始，但不是按顺序进行或顺序完成，通常是交叉进行的（一个阶段执行中激活另外一个阶段）。

## 1.1. 加载

### 1.1.1. 非数组类

通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个 Class 对象。

- 使用类加载器通过完全限定名找到字节码文件，将其以二进制流的形式读入内存。
- 将字节流所代表的静态存储结构转化为方法区的运行时数据结构（包含 class 文件常量池进入运行时常量池的过程）。
- 在内存中生成一个该类的 `java.lang.Class` 对象，作为方法区这个类的各种数据的访问入口。

### 1.1.2. 数组类

本身不通过类加载器创建，而是由 Java 虚拟机直接创建，但数组类的元素类型使用类加载器创建。

- 如果数组的组件类型是引用类型（如`Integer[]` ），那就递归去加载这个组件类型，数组类将在加载该组件类型的类加载器的类名称空间上被标识。
- 如果数组的组件类型不是引用类型（如 `int[]` ），Java 虚拟机将会把数组类标记为与引导类加载器关联。
- 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认为 public。

## 1.2. 验证

确保 Class 文件的字节流中包含信息符合当前虚拟机规范。

### 1.2.1. 文件格式验证

验证字节流是否符合 Class 文件格式的规范，且能被当前版本的虚拟机处理。

只有通过后，字节流才会进入内存的方法区中进行存储。以后的验证阶段都是基于方法区的存储结构进行，不会再直接操作字节流。

- 是否以 0xCAFEBABE 开头。

- 主、次版本号是否在当前虚拟机的处理范围之内。
- 常量池中的常量是否有不被支持的常量类型。
- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
- Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息。
- 其他验证...

### 1.2.2. 元数据验证

对字节码描述的信息进行语义分析，保证其描述的信息符合 Java 语言规范的要求。

- 这个类是否有除了 `java.lang.Object` 之外的父类。
- 这个类的父类是否继承了不允许被继承的类（被 `final` 修饰的类）。
- 如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法。
- 类中的字段、方法是否与父类产生矛盾。
- 其他验证...

### 1.2.3. 字节码验证

对类的方法体进行校验分析，保证方法在运行时不会危害虚拟机安全。

- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。
- 保证跳转指令不会跳转到方法体以外的字节码指令上。
- 保证方法体中的类型转换是有效的。

### 1.2.4. 符号引用验证

发生在解析阶段，其对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保解析动作能正常执行。

- 符号引用中通过字符串描述的全限定名是否能找到对应的类。
- 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
- 符号引用中的类、字段、方法的访问性是否可被当前类访问。

## 1.3. 准备

为类变量 (`static`变量) 分配内存并且设置该类变量的初始值，这些内存都将分配在方法区中。

## 1.4. 目标变量

仅包括类变量（`static`变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。

### 1.4.1. 初始值

通常是数据类型默认的初始值，而不是被在 Java 代码中被显式地赋予的值。

```java
// 这一步只将 i 初始化为 0。赋值为 5 是在之后的初始化步骤中完成。
static int i = 5; 
```

- 基本数据类型的类变量和全局变量，默认为零值（`0`、`false`、`''`），而局部变量在使用前必须显式地赋值，否则编译不通过。
- 引用数据类型的变量，默认为零值（`null`）。
- 被 `static` 和 `final` 修饰的常量，必须在声明的时候显式地赋值，否则编译不通过，因为 `final` 在编译的时候就会分配了。
- 被 `final` 修饰的常量，没有默认零值，既可以在声明时显式地赋值，也可以在类初始化时（构造方法中）显式地赋值。
- 在数组初始化时，数组中的各元素将根据对应数据类型被赋予默认值。

## 1.5. 解析

虚拟机将常量池内的符号引用替换为直接引用的过程，有类或接口的解析，字段解析，类方法解析，接口方法解析等。

- 符号引用：一组符号来描述所引用的目标，可以是任何字面量（简单而言就是代码）。
- 直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄（简单而言就是内存地址）。

## 1.6. 初始化

对类的静态变量赋真正的初始值，对成员变量赋初始值。

```java
// 主要有两种方式：
// ① 声明类变量时指定初始值；
static int i = 5; 
// ② 使用静态代码块为类变量指定初始值。
static int i; 
static { i = 5; }
```

### 1.6.1. 初始化顺序

1. 假如类还没有被加载和连接，则程序先加载并连接该类。
2. 假如类的直接父类还没有被初始化，则先初始化其直接父类。
3. 假如类中有初始化语句，则系统依次执行这些初始化语句。

### 1.6.2. 主动引用（初始化时机）

只有当对类主动引用的时候才会导致类的初始化。

- 创建类的实例（new、反射、clone、反序列化）。

- 读写类/接口的静态变量。
- 调用类的静态方法。
- 使用 `java.lang.reflect` 包中的方法对类进行反射调用。
- 子类初始化时，其父类也会被初始化；子接口初始化时，其父接口不会被初始化。
- JVM 启动时的启动类（包含 `main()` 方法的类）。

### 1.6.3. 被动引用

当对类被动引用的时候不会导致类的初始化。

**【通过子类引用父类的静态变量】**

只会触发父类的初始化，而不会触发子类的初始化。

```java
// 父类
public class SuperClass {
    static {
        System.out.println("父类正在初始化");
    }

    public static String name = "这是父类";
}
// 子类
public class SubClass extends SuperClass {
    static {
        System.out.println("子类正在初始化");
    }
}
// 测试类
public class InitTest {
    public static void main(String[] args) {
        // 通过子类引用父类中定义的静态变量，不会初始化子类
        System.out.println(SubClass.name);
        // 运行结果：
        // 父类正在初始化
        // 这是父类
    }
}
```

【**通过数组定义集合定义来引用类**】

JVM 会自动生成生成一个继承于 Object 的子类，并由字节码指令 newarray 创建。

```java
// 测试类
public class InitTest {
    public static void main(String[] args) {
        SuperClass[] arrays = new SuperClass[10];
        ArrayList<SubClass> list = new ArrayList<>();
        System.out.println("数组元素个数：" + arrays.length);
        System.out.println("列表元素个数：" + list.size());
        // 运行结果：
        // 数组元素个数：10
        // 列表元素个数：0
    }
}
```

**【静态常量】**

静态常量在编译阶段就会存入调用类的常量池中，因此不会触发初始化。

```java
// 常量类
public class ConstClass {
    static {
        System.out.println("有常量的类正在初始化");
    }

    public static final String NAME = "这是常量类";
}
// 测试类
public class InitTest {
    public static void main(String[] args) {
        System.out.println(ConstClass.NAME);
        // 运行结果：
        // 这是常量类
    }
}
```

---

# 2. 类加载器

类加载器负责加载所有的类，在内存中生成一个实例对象。并且采用按需加载模式。

## 2.1. 类加载器的分类

![img](https://raw.githubusercontent.com/ren-p/AndroidLearningNotes/main/img/20201128-210412-0637b7585d45400fadcd4a6c30e8a00a.png)

### 2.1.1. 引导类加载器（bootstrap class loader）

由 C++ 语言实现，并不继承自 `java.lang.ClassLoader`，是虚拟机自身的一部分，主要加载 JVM 自身需要的类。

- 加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar 和 sun.boot.class.path 路径下的内容），加载包名为 java、javax、sun 等开头的类。
- 加载扩展类加载器和应用程序类加载器，并指定他们的父类加载器。

### 2.1.2. 扩展类加载器（extensions class loader）

由 Java 语言实现，父类加载器为 null。

- 用来加载 Java 的扩展库 (JAVA_HOME/jre/ext/*.jar，或 java.ext.dirs 路径下的内容) 。
- 由 ExtClassLoader 实现。

### 2.1.3. 应用程序类加载器（application class loader）

由 Java 语言实现，父类加载器为 ExtClassLoader。也称为系统类加载器。

- 它根据 Java 应用的类路径（classpath，java.class.path 路径下的内容）来加载 Java 类。一般来说 Java 应用的类都是它加载的。
- 由 AppClassLoader 实现。

### 2.1.4. 自定义类加载器

继承 java.lang.ClassLoader 类，实现自己的类加载器。

- 遵守双亲委派模型：继承 ClassLoader，重写 `findClass()` 方法。
- 破坏双亲委派模型：继承 ClassLoader，重写 `loadClass()` 方法。

## 2.2. 类加载步骤

1. 检测此 Class 是否加载过（缓冲区中是否有此 Class），如果有直接进入第 8 步，否则进入第 2 步。
2. 如果没有父类加载器，则要么 Parent 是根类加载器，要么本身就是根类加载器，则跳到第 4 步，如果父类加载器存在，则进入第 3 步。
3. 请求使用父类加载器去载入目标类，如果载入成功则跳至第 8 步，否则接着执行第 5 步。
4. 请求使用根类加载器去载入目标类，如果载入成功则跳至第 8 步，否则跳至第 7 步。
5. 当前类加载器尝试寻找 Class 文件，如果找到则执行第 6 步，如果找不到则执行第 7 步。
6. 从文件中载入 Class，成功后跳至第 8 步。
7. 抛出 ClassNotFountException 异常。
8. 返回对应的 java.lang.Class 对象。

## 2.3. 类加载机制

- 全盘负责：同一个类加载器负责加载该 Class，以及所依赖和引用的其他 Class，除非显式指定其他类加载器。

- 双亲委派：先让父类加载器尝试加载该 Class，只有在父类加载器无法加载该类时，自己才尝试加载该类。
- 缓存机制：程序需要使用某个 Class 时，类加载器先从缓存区中获取，只有不存在时才执行加载并存入缓冲区。因此动态修改了 Class 后，必须重启 JVM 后修改才会生效。

## 2.4. 双亲委派

![img](https://raw.githubusercontent.com/ren-p/AndroidLearningNotes/main/img/20201128-210516-934640a357f1c5ce0a48fd0236d4dfdb.png)

### 2.4.1. 执行流程

- 上浮：一个类加载器收到加载请求，他并不会去加载该类，而是把这个请求委派给父类加载器（层层往上），因此所有的类加载请求最终都会传送到启动类加载器。
- 下沉：只有当父类加载器在其搜索范围内无法找到所需的类，子类加载器会尝试去自己加载（层层往下）。

### 2.4.2. 双亲委派的优点

- 避免重复加载。相同的 class 文件被不同的类加载器加载就是不同的两个类，父类加载器已经加载过该类，子类加载器没必要再加载一次。
- 提高安全性。防止用户自己编写的类动态替换 Java 的一些核心类。（比如 java.lang.Integer，而启动类加载器找到了这个名字且该类已被加载，所以并不会重新加载其他的 java.lang.Integer，而是直接返回已加载过的 Integer.class）

### 2.4.3. 破坏双亲委派

- 双亲委派模型不是一种强制性约束，它是一种 Java 设计者推荐使用类加载器的方式。
- 有时必须违反这个约束。例如 SPI（Service Provider Interface）, 是 Java 提供的一套用来被第三方实现或者扩展的 API，它可以用来启用框架扩展和替换组件。
- 线程上下文类加载器（Thread Context ClassLoader）可以通过 java.lang.Thread 类的 setContextClassLoader() 方法设置，默认从父线程中继承（父线程默认为应用程序类加载器）。